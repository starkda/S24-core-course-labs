# Lab 13

## Task 2

```
djovi@djovi-NBD-WXX9:~/PycharmProjects/S24-core-course-labs/k8s$ kubectl get po,sts,svc,pvc
NAME               READY   STATUS    RESTARTS      AGE
pod/app-python-0   1/1     Running   4 (23s ago)   4m23s
pod/app-python-1   1/1     Running   4 (20s ago)   4m23s

NAME                          READY   AGE
statefulset.apps/app-python   2/2     4m23s

NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
service/app-python   NodePort    10.102.60.122   <none>        5000:32384/TCP   4m23s
service/kubernetes   ClusterIP   10.96.0.1       <none>        443/TCP          29d

NAME                                      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/data-app-python-0   Bound    pvc-4dfea5e6-dfb8-4d36-a3ae-5ef2d1ae0d62   1Gi        RWO            standard       6m16s
persistentvolumeclaim/data-app-python-1   Bound    pvc-cd5e8522-e4a6-44ad-99ea-b6ff85f80d24   1Gi        RWO            standard       4m23s

```

```
$ kubectl exec pod/py-app-python-0 -- cat /app/data/visits
44
$ kubectl exec pod/py-app-python-1 -- cat /app/data/visits
18
```

The first pod saw more visits than the second one, likely because minikube service predominantly routed requests to the
first pod, while the second one primarily received healthcheck requests. Introducing a load balancer could have resulted
in a more equitable distribution of traffic between the two pods.

### Ordering guarantees

Ordering guarantees are not needed for the app, as we have the flexibility to start as many pods as we want in parallel
because each pod is independent of others.